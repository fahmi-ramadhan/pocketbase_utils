import 'package:code_builder/code_builder.dart' as code_builder;
import 'package:json_annotation/json_annotation.dart';
import 'package:pocketbase_utils/src/templates/date_time_json_methods.dart';
import 'package:pocketbase_utils/src/utils/string_utils.dart';
import 'package:pocketbase_utils/src/utils/utils.dart';
import 'package:recase/recase.dart';

part 'field.g.dart';

enum FieldType {
  text,
  editor,
  number,
  bool,
  email,
  url,
  date,
  autodate,
  select,
  relation,
  file,
  json,
  password,
  geoPoint,
}

@JsonSerializable()
final class Field {
  const Field({
    required this.name,
    required this.type,
    this.maxSelect,
    this.min,
    this.max,
    this.onlyInt,
    this.id,
    this.values,
    this.required = false,
    this.hidden = false,
    this.system = false,
    this.docs,
  });

  factory Field.fromJson(Map<String, dynamic> json) => _$FieldFromJson(json);

  final String? id;
  final String name;
  final FieldType type;

  /// "Nonempty" or "Nonfalsey" checkbox in the PocketBase admin panel.
  /// If this is set to true, the value can not be nullable, empty string, or false.
  final bool required;

  final int? maxSelect;
  @JsonKey(fromJson: jsonValueParseToInt)
  final int? min;
  @JsonKey(fromJson: jsonValueParseToInt)
  final int? max;
  final bool? onlyInt;
  final List<String>? values;

  /// Hidden fields are not included in the Json API response or filters.
  /// (from the PocketBase documentation)
  final bool hidden;

  /// System fields are automatically generated by PocketBase and cannot be modified.
  /// (from the PocketBase documentation)
  final bool system;

  final String? docs;

  String get nameInCamelCase {
    final nameInCamelCase = ReCase(name).camelCase;
    if (dartKeywords.contains(nameInCamelCase)) {
      return '${nameInCamelCase}Field';
    }
    return nameInCamelCase;
  }

  Map<String, dynamic> toJson() => _$FieldToJson(this);

  bool get hiddenOrSystem => hidden || system;

  String enumTypeName(String className) => '$className${name.capFirstChar()}Enum';

  /// [hidden] property makes any field nullable.
  ///
  /// For bool type fields the [required] property is the "Nonfalsey" toggle in the admin panel.
  bool get isNullable => hidden || (required == false && type != FieldType.bool);
  bool get isNonNullable => !isNullable;

  code_builder.Reference fieldTypeRef(String className, {bool forceNullable = false}) {
    var fieldTypeRef = switch (type) {
      FieldType.text || FieldType.editor || FieldType.email || FieldType.url || FieldType.password => 'String',
      FieldType.number => onlyInt == true ? 'int' : 'double',
      FieldType.bool => 'bool',
      FieldType.date => 'DateTime',
      FieldType.autodate => 'DateTime',
      FieldType.select => maxSelect == 1 ? enumTypeName(className) : 'List<${enumTypeName(className)}>',
      FieldType.relation => maxSelect == 1 ? 'String' : 'List<String>',
      FieldType.file => maxSelect == 1 ? 'String' : 'List<String>',
      FieldType.json => 'dynamic',
      FieldType.geoPoint => 'GeoPoint',
    };

    if (fieldTypeRef != 'dynamic' && (isNullable || forceNullable)) {
      fieldTypeRef += '?';
    }

    return code_builder.refer(fieldTypeRef);
  }

  code_builder.Expression? _jsonAnnotation(String className) {
    code_builder.Expression? result;

    final jsonKeyNamedArguments = <String, code_builder.Expression>{
      if (type == FieldType.date) ...{
        'toJson': required == true
            ? code_builder.refer(pocketBaseDateTimeToJsonMethodName)
            : code_builder.refer(pocketBaseNullableDateTimeToJsonMethodName),
        'fromJson': required == true
            ? code_builder.refer(pocketBaseDateTimeFromJsonMethodName)
            : code_builder.refer(pocketBaseNullableDateTimeFromJsonMethodName),
      },
      if (name != nameInCamelCase) 'name': code_builder.literal(name),
      if (type == FieldType.select && isNullable)
        'unknownEnumValue': code_builder
            .refer('JsonKey', 'package:json_annotation/json_annotation.dart')
            .property('nullForUndefinedEnumValue')
    };

    if (jsonKeyNamedArguments.isNotEmpty) {
      result = code_builder.refer('JsonKey', 'package:json_annotation/json_annotation.dart').newInstance(
        [],
        jsonKeyNamedArguments,
      );
    }

    return result;
  }

  code_builder.Field toCodeBuilder(String className, {bool shouldOverride = false}) {
    return code_builder.Field((f) {
      final jsonAnnotation = _jsonAnnotation(className);

      f
        ..name = nameInCamelCase
        ..modifier = code_builder.FieldModifier.final$
        ..type = fieldTypeRef(className)
        ..annotations.addAll([
          if (jsonAnnotation != null) jsonAnnotation,
          if (shouldOverride) code_builder.refer('override'),
        ]);
    });
  }

  List<code_builder.Field> additionalFieldOptionsAsFields() {
    return [
      if (min != null)
        code_builder.Field((f) => f
          ..static = true
          ..modifier = code_builder.FieldModifier.constant
          ..name = '${name}MinValue'
          ..assignment = code_builder.Code(min.toString())),
      if (max != null)
        code_builder.Field((f) => f
          ..static = true
          ..modifier = code_builder.FieldModifier.constant
          ..name = '${name}MaxValue'
          ..assignment = code_builder.Code(max.toString()))
    ];
  }
}

const dartKeywords = {
  'abstract',
  'as',
  'assert',
  'async',
  'await',
  'break',
  'case',
  'catch',
  'class',
  'const',
  'continue',
  'covariant',
  'default',
  'deferred',
  'do',
  'dynamic',
  'else',
  'enum',
  'export',
  'extends',
  'extension',
  'external',
  'factory',
  'false',
  'final',
  'finally',
  'for',
  'Function',
  'get',
  'hide',
  'if',
  'implements',
  'import',
  'in',
  'interface',
  'is',
  'late',
  'library',
  'mixin',
  'native',
  'new',
  'null',
  'on',
  'operator',
  'part',
  'patch',
  'required',
  'rethrow',
  'return',
  'set',
  'show',
  'static',
  'super',
  'switch',
  'sync',
  'this',
  'throw',
  'true',
  'try',
  'typedef',
  'var',
  'void',
  'while',
  'with',
  'yield',
};

const baseFields = [
  Field(
    name: 'id',
    type: FieldType.text,
    required: true,
    system: true,
  ),
  Field(
    name: 'collectionId',
    type: FieldType.text,
    required: true,
    system: true,
  ),
  Field(
    name: 'collectionName',
    type: FieldType.text,
    required: true,
    system: true,
  ),
];

const List<Field> authFields = [
  ...baseFields,
  Field(
    name: 'email',
    type: FieldType.email,
    system: true,
  ),
  Field(
    name: 'emailVisibility',
    type: FieldType.bool,
    system: true,
  ),
  Field(
    name: 'verified',
    type: FieldType.bool,
    system: true,
  ),
  Field(
    name: 'tokenKey',
    type: FieldType.text,
    hidden: true,
    required: true,
    system: true,
  ),
  Field(
    name: 'password',
    type: FieldType.password,
    hidden: true,
    required: true,
    system: true,
  ),
  Field(
    name: 'passwordConfirm',
    type: FieldType.text,
    hidden: true,
    system: true,
  ),
];
